<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Algoritmos.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.github.josecxsta:cs-2019-01</a> &gt; <a href="index.source.html" class="el_package">com.github.josecxsta.ufg.cs.aula01.domain</a> &gt; <span class="el_source">Algoritmos.java</span></div><h1>Algoritmos.java</h1><pre class="source lang-java linenums">package com.github.josecxsta.ufg.cs.aula01.domain;

/**
* Implementa algoritmos matemáticos.
* @author José da Costa
*/
public class Algoritmos {

    /**
    * Limite para o argumento do método prop153.
    */
    public static final int LIMIT_PROP153 = 999;

    /**
    * Limite para o argumento do método prop3025.
    */
    public static final int LIMIT_PROP3025 = 9999;

    /**
    * Atributo que representa o número 1 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_1 = 1;

    /**
    * Atributo que representa o número 2 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_2 = 2;

    /**
    * Atributo que representa o número 3 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_3 = 3;

    /**
    * Atributo que representa o número 4 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_4 = 4;
    /**
    * Atributo que representa o número 5 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_5 = 5;

    /**
    * Atributo que representa o número 7 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_7 = 7;

    /**
    * Atributo que representa o número 10 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_10 = 10;

    /**
    * Atributo que representa o número 100 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_100 = 100;

    /**
    * Atributo que representa o número 1000 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_1000 = 1000;

    /**
    * Atributo que representa o número 12 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_12 = 12;

    /**
    * Atributo que representa o número 400 a fim de evitar
    * a utilização de número mágico.
    */
    public static final int DIG_400 = 400;

    /**
    * Evita a instanciação da clase.
    * @throws UnsupportedOperationException
    */
<span class="fc" id="L88">    protected Algoritmos() {</span>
<span class="fc" id="L89">        throw new UnsupportedOperationException();</span>
    }

    /**
    * Calcula se numero satisfaz a propriedade 153.
    * @param number numero.
    * @return se satisfaz propriedade 153
    * @throws IllegalArgumentException se argumento nao estiver entre 100 e 999.
    */
    public static boolean prop153(final int number) {

<span class="fc bfc" id="L100" title="All 4 branches covered.">        if (number &lt; 0 || number &gt; LIMIT_PROP153) {</span>
<span class="fc" id="L101">            throw new IllegalArgumentException(&quot;Argumento fora da faixa&quot;);</span>
        }

<span class="fc" id="L104">        final int c = number / DIG_100;</span>
<span class="fc" id="L105">        final int du = number % DIG_100;</span>
<span class="fc" id="L106">        final int d = (du / DIG_10);</span>
<span class="fc" id="L107">        final int u = (du % DIG_10);</span>

<span class="fc" id="L109">        final int c3 = c * c * c;</span>
<span class="fc" id="L110">        final int d3 = d * d * d;</span>
<span class="fc" id="L111">        final int u3 = u * u * u;</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">        return (c3 + d3 + u3) == number;</span>
    }

    /**
    * Calcula se numero satisfaz a propriedade 3025.
    * @param number numero.
    * @return se satisfaz propriedade 3025
    * @throws IllegalArgumentException se argumento
    nao estiver entre 100 e 9999.
    */
    public static boolean prop3025(final int number) {

<span class="fc bfc" id="L125" title="All 4 branches covered.">        if (number &lt; 0 || number &gt; LIMIT_PROP3025) {</span>
<span class="fc" id="L126">            throw new IllegalArgumentException(&quot;Argumento fora da faixa&quot;);</span>
        }

<span class="fc" id="L129">        int i = (number / DIG_100);</span>
<span class="fc" id="L130">        int j = (number % DIG_100);</span>

<span class="fc" id="L132">        int ij = (int) Math.round(i + j);</span>

<span class="fc" id="L134">        int x = ij * ij;</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">        return (x == number);</span>

    }

    /**
    * Calcula se o numero eh um quadrado perfeito.
    * @param n numero
    * @return se numero é quadrado perfeito
    * @throws IllegalArgumentException se n for menor que 1
    */
    public static boolean quadradoPerfeito(final int n) {

<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (n &lt; 1) {</span>
<span class="fc" id="L149">            throw new IllegalArgumentException(&quot;n deve ser maior que 0&quot;);</span>
        }

<span class="fc" id="L152">        int i = 1;</span>
<span class="fc" id="L153">        int s = 1;</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">        while (s &lt; n) {</span>
<span class="fc" id="L156">            i = i + 2;</span>
<span class="fc" id="L157">            s = s + i;</span>
        }

<span class="fc bfc" id="L160" title="All 2 branches covered.">        return (s == n);</span>

    }

    /**
    * Calcula a raiz quadrada de um numero de acordo com a precisão fornecida.
    * @param x numero
    * @param y precisão
    * @return raiz quadrada
    */
    public static int raizQuadrada(final int x, final int y) {

<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (x &lt; 1) {</span>
<span class="fc" id="L173">            throw new IllegalArgumentException(&quot;x deve ser maior que 0&quot;);</span>
        }

<span class="fc" id="L176">        int r = 1;</span>

<span class="fc" id="L178">        int argY = y;</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">        while (0 &lt;= argY) {</span>
<span class="fc" id="L181">            r = (r + (x / r)) / 2;</span>
<span class="fc" id="L182">            argY = argY - 1;</span>
        }

<span class="fc" id="L185">        return r;</span>

    }

    /**
    * Calcula a razão aurea entre dois numeros.
    * @param x 1º número
    * @param y 2º número
    * @param k precisão
    * @return razão aurea entre x e y
    * @throws IllegalArgumentException se x for menor que 0,
    se k menor que 1
    se y menor que x.
    */
    public static int razaoAurea(final int x, final int y, final int k) {

<span class="pc bpc" id="L201" title="1 of 6 branches missed.">        if (x &lt; 0 || x &gt; y || k &lt;= 0) {</span>
<span class="fc" id="L202">            throw new IllegalArgumentException(&quot;argumentos fora da faixa&quot;);</span>
        }

<span class="fc" id="L205">        int c = y;</span>
<span class="fc" id="L206">        int a = x;</span>
<span class="fc" id="L207">        int i = 1;</span>

<span class="fc bfc" id="L209" title="All 2 branches covered.">        while (i &lt;= k) {</span>
<span class="fc" id="L210">            final int t = c;</span>
<span class="fc" id="L211">            c = c + a;</span>
<span class="fc" id="L212">            a = t;</span>
<span class="fc" id="L213">            i++;</span>
        }

<span class="fc" id="L216">        final int response = c / a;</span>

<span class="fc" id="L218">        return response;</span>

    }

    /**
    * Produz uma aproximação do valor de PI baseado no número de
    iterações fornecido, onde quanto maior o número de
    iterações, maior a precisão de PI.
    * @param n numero de iteracoes
    * @return aproximacao do valor de PI
    * @throws IllegalArgumentException se n for menor que 1
    */
    public static int valorPi(final int n) {

<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (n &lt; 1) {</span>
<span class="fc" id="L233">            throw new IllegalArgumentException(&quot;n deve ser positivo&quot;);</span>
        }

<span class="fc" id="L236">        int i = 1;</span>
<span class="fc" id="L237">        int s = -1;</span>
<span class="fc" id="L238">        int d = -1;</span>
<span class="fc" id="L239">        int p = 0;</span>

<span class="fc bfc" id="L241" title="All 2 branches covered.">        while (i &lt;= n) {</span>
<span class="fc" id="L242">            d = d + 2;</span>
<span class="fc" id="L243">            s = -1 * s;</span>
<span class="fc" id="L244">            p = p + (DIG_4 * s / d);</span>
<span class="fc" id="L245">            i = i + 1;</span>
        }

<span class="fc" id="L248">        return p;</span>

    }

    /**
    * Calcula o fatorial de dado numero.
    * @param n numero
    * @return fatorial de n
    * @throws IllegalArgumentException Se n for menor que 1
    */
    public static int fatorial(final int n) {

<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (1 &gt; n) {</span>
<span class="fc" id="L261">            throw new IllegalArgumentException(&quot;n deve ser positivo&quot;);</span>
        }

<span class="fc" id="L264">        int i = 2;</span>
<span class="fc" id="L265">        int f = 1;</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">        while (i &lt;= n) {</span>
<span class="fc" id="L268">            f = f * i;</span>
<span class="fc" id="L269">            i = i + 1;</span>
        }

<span class="fc" id="L272">        return f;</span>

    }

    /**
    * Calcula o n-esimo numero da sequência de Fibonacci.
    * @param n numero
    * @throws IllegalArgumentException se n for menor que zero.
    * @return c n-esimo numero de Fibonacci.
    */
    public static int fibonacci(final int n) {

<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (0 &gt; n) {</span>
<span class="fc" id="L285">            throw new IllegalArgumentException(&quot;n deve ser positivo&quot;);</span>
        }

<span class="fc" id="L288">        int a = 0;</span>
<span class="fc" id="L289">        int c = 1;</span>

<span class="fc bfc" id="L291" title="All 4 branches covered.">        if (n == 0 || n == 1) {</span>
<span class="fc" id="L292">            return n;</span>
        }

<span class="fc" id="L295">        int i = 2;</span>
        int t;

<span class="fc bfc" id="L298" title="All 2 branches covered.">        while (i &lt;= n) {</span>
<span class="fc" id="L299">            t = c;</span>
<span class="fc" id="L300">            c = c + a;</span>
<span class="fc" id="L301">            a = t;</span>
<span class="fc" id="L302">            i++;</span>
        }

<span class="fc" id="L305">        return c;</span>

    }

    /**
    * Calcula maior divisor comum entre dois numeros.
    * @param x 1º numero
    * @param y 2º numero
    * @return maior divisor comum entre x e y
    * @throws IllegalArgumentException Se y for maior que x
    ou y menor do que zero.
    */
    public static int maiorDivisorComum(final int x, final int y) {

<span class="pc bpc" id="L319" title="1 of 4 branches missed.">        if (x &lt; 1 || y &gt; x) {</span>
<span class="fc" id="L320">            throw new IllegalArgumentException(&quot;Argumento fora da faixa&quot;);</span>
        }

        int m;

<span class="fc" id="L325">        int argX = x;</span>
<span class="fc" id="L326">        int argY = y;</span>

<span class="fc bfc" id="L328" title="All 2 branches covered.">        while (argY != 0) {</span>
<span class="fc" id="L329">            m = argX % argY;</span>
<span class="fc" id="L330">            argX = argY;</span>
<span class="fc" id="L331">            argY = m;</span>
        }

<span class="fc" id="L334">        return argX;</span>

    }

    /**
    * Calcula maior divisor comum entre dois numeros.
    * @param a 1º numero
    * @param b 2º numero
    * @return maior divisor comum entre a e b
    * @throws IllegalArgumentException Se y for maior que x
    ou y menor do que zero.
    */
    public static int maiorDivisorComum2(final int a, final int b) {

<span class="pc bpc" id="L348" title="1 of 4 branches missed.">        if (b &lt; 1 || b &gt; a) {</span>
<span class="fc" id="L349">            throw new IllegalArgumentException(&quot;Argumento fora da faixa&quot;);</span>
        }

<span class="fc" id="L352">        int argA = a;</span>
<span class="fc" id="L353">        int argB = b;</span>

<span class="fc bfc" id="L355" title="All 2 branches covered.">        while (argA != argB) {</span>

<span class="fc bfc" id="L357" title="All 2 branches covered.">            if (argA &gt; argB) {</span>
<span class="fc" id="L358">                argA = argA - argB;</span>
<span class="fc" id="L359">            } else {</span>
<span class="fc" id="L360">                argB = argB - argA;</span>
            }

        }

<span class="fc" id="L365">        return argA;</span>

    }

    /**
    * Calcula se numero é primo.
    * @param numero numero
    * @return se numero é primo ou não
    * @throws IllegalArgumentException se n for numero menor ou igual a 1
    */
    public static boolean numeroPrimo(final int numero) {

<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (numero &lt; 0) {</span>
<span class="fc" id="L378">            throw new IllegalArgumentException(&quot;Argumento deve ser positivo&quot;);</span>
        }

<span class="fc" id="L381">        int i = 2;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        while (i &lt; numero) {</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">            if (numero % i == 0) {</span>
<span class="fc" id="L384">                return false;</span>
            }

<span class="fc" id="L387">            i++;</span>
        }

<span class="fc" id="L390">        return true;</span>

    }

    /**
    * Calcula a soma dos primeiros numeros naturais.
    * @param n quantidade de numeros naturais a serem somados.
    * @return resultado da soma.
    * @throws IllegalArgumentException se numero n for menor que 2
    */
    public static int somaPrimeirosNaturais(final int n) {

<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (1 &gt; n) {</span>
<span class="fc" id="L403">            throw new IllegalArgumentException(&quot;n deve ser maior que 1&quot;);</span>
        }

<span class="fc" id="L406">        int i = 2;</span>
<span class="fc" id="L407">        int s = 1;</span>

<span class="fc bfc" id="L409" title="All 2 branches covered.">        while (i &lt;= n) {</span>
<span class="fc" id="L410">            s = s + i;</span>
<span class="fc" id="L411">            i++;</span>
        }

<span class="fc" id="L414">        return s;</span>

    }

    /**
    * Calcula o resto da divisao entre dois numeros inteiros.
    * @param x numerador
    * @param y denominador
    * @return resto da divisao entre os dois numeros
    * @throws IllegalArgumentException se x ou y for menor que 0
    */
    public static int restoDivisao(final int x, final int y) {

<span class="fc bfc" id="L427" title="All 4 branches covered.">        if (y &lt; 0 || x &lt; 0) {</span>
<span class="fc" id="L428">            throw new IllegalArgumentException(&quot;x e y devem ser maiores que 0&quot;);</span>
        }

<span class="fc" id="L431">        int s = x;</span>

<span class="fc bfc" id="L433" title="All 2 branches covered.">        while (y &lt;= s) {</span>
<span class="fc" id="L434">            s = s - y;</span>
        }

<span class="fc" id="L437">        return s;</span>
    }

    /**
    * Calcula resultado de polinômio.
    * @param n numero
    * @param c array de coeficientes
    * @return polinomio de n
    * @throws IllegalArgumentException se argumento não for positivo.
    */
    public static int polinomio(final int n, final int[] c) {

<span class="fc" id="L449">        final int grau = c.length;</span>

<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (n &lt; 0) {</span>
<span class="fc" id="L452">            throw new IllegalArgumentException(&quot;argumento deve ser positivo&quot;);</span>
        }

<span class="fc" id="L455">        int p = c[grau - 1];</span>

        int i;

<span class="fc bfc" id="L459" title="All 2 branches covered.">        for (i = grau - 2; i &gt;= 0; i--) {</span>
<span class="fc" id="L460">            p = p * n + c[i];</span>
        }

<span class="fc" id="L463">        return p;</span>

    }

    /**
    * Aplica o método conhecido por Crivo de Eratostenes para
    identificar se um valor é primo.
    * @param a colecao de numeros
    * @param n valor
    * @return se o valor é primo
    * @throws IllegalArgumentException se n nao for maior que 1.
    */
    public static boolean crivoEratostenes(final int[] a, final int n) {

<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (n &lt; 2) {</span>
<span class="fc" id="L478">            throw new IllegalArgumentException(&quot;n deve ser maior que 1&quot;);</span>
        }

<span class="fc" id="L481">        int i = 2;</span>
<span class="fc" id="L482">        final int limite = (int) Math.sqrt(n);</span>

<span class="fc bfc" id="L484" title="All 2 branches covered.">        while (i &lt;= limite) {</span>

<span class="pc bpc" id="L486" title="1 of 2 branches missed.">            if (a[i] == 0) {</span>

<span class="fc" id="L488">                int multiplo = i + i;</span>

<span class="fc bfc" id="L490" title="All 2 branches covered.">                while (multiplo &lt;= n) {</span>
<span class="fc" id="L491">                    a[multiplo] = 1;</span>
<span class="fc" id="L492">                    multiplo++;</span>
                }

            }

<span class="fc" id="L497">            i++;</span>

        }

<span class="fc bfc" id="L501" title="All 2 branches covered.">        return a[n] == 1;</span>

    }

    /**
    * Calcula potencia apenas usando somas.
    * @param x numero
    * @param y numero de iteracoes para calcular a potencia de x
    * @return potencia
    * @throws IllegalArgumentException Se algum dos numeros for menor que zero.
    */
    public static int potenciaSomas(final int x, final int y) {

<span class="fc bfc" id="L514" title="All 4 branches covered.">        if (x &lt; 0 || y &lt; 0) {</span>
<span class="fc" id="L515">            throw new IllegalArgumentException(&quot;x e y devem ser positivos&quot;);</span>
        }

<span class="fc" id="L518">        int potencia = 1;</span>
<span class="fc" id="L519">        int i = 1;</span>

<span class="fc bfc" id="L521" title="All 2 branches covered.">        while (i &lt;= y) {</span>
<span class="fc" id="L522">            potencia = potencia * x;</span>
<span class="fc" id="L523">            i++;</span>
        }

<span class="fc" id="L526">        return potencia;</span>
    }

    /**
    * Calcula o produto dos numeros inteiros fornecidos.
    * @param a multiplicando
    * @param b multiplicador
    * @return resultado da multiplicação
    * @throws IllegalArgumentException se a ou b for menor que 1
    */
    public static int produtoDeInteiros(final int a, final int b) {

<span class="fc bfc" id="L538" title="All 4 branches covered.">        if (a &lt; 1 || b &lt; 1) {</span>
<span class="fc" id="L539">            String msg = &quot;a e b devem ser positivos&quot;;</span>
<span class="fc" id="L540">            throw new IllegalArgumentException(msg);</span>
        }

<span class="fc" id="L543">        int totalParcelas = a;</span>
<span class="fc" id="L544">        int parcela = b;</span>

<span class="fc bfc" id="L546" title="All 2 branches covered.">        if (b &lt; a) {</span>
<span class="fc" id="L547">            totalParcelas = b;</span>
<span class="fc" id="L548">            parcela = a;</span>
        }

<span class="fc" id="L551">        int i = 1;</span>
<span class="fc" id="L552">        int s = 0;</span>

<span class="fc bfc" id="L554" title="All 2 branches covered.">        while (i &lt;= totalParcelas) {</span>
<span class="fc" id="L555">            s = s + parcela;</span>
<span class="fc" id="L556">            i = i + 1;</span>
        }

<span class="fc" id="L559">        return s;</span>
    }

    /**
    * Calcula o logaritmo natural de um número expoente com a
    precisão fornecida.
    * @param n número expoente
    * @param precisao precisão
    * @return logaritmo natural
    * @throws IllegalArgumentException se n for menor que 1 ou precisao menor que 2
    */
    public static int logaritmo(final int n, final int precisao) {

<span class="fc bfc" id="L572" title="All 4 branches covered.">        if (n &lt; 1 || precisao &lt; 2) {</span>
<span class="fc" id="L573">            throw new IllegalArgumentException(&quot;argumentos fora da faixa&quot;);</span>
        }

<span class="fc" id="L576">        int i = 2;</span>
<span class="fc" id="L577">        int e = DIG_1 + n;</span>
<span class="fc" id="L578">        int numerador = n;</span>
<span class="fc" id="L579">        int denominador = DIG_1;</span>

<span class="fc bfc" id="L581" title="All 2 branches covered.">        while (i &lt;= precisao) {</span>
<span class="fc" id="L582">            numerador = numerador * numerador;</span>
<span class="fc" id="L583">            denominador = denominador * i;</span>
<span class="fc" id="L584">            e = e + (numerador / denominador);</span>
<span class="fc" id="L585">            i = i + DIG_1;</span>
        }

<span class="fc" id="L588">        return e;</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>